================================================================================
                    AGROBR - ROADMAP DE MELHORIAS v0.2.0+
================================================================================
# Role
Desenvolvedor sÃªnior do projeto **agrobr** â€” wrapper Python para dados
agrÃ­colas brasileiros (CEPEA, CONAB, IBGE).

# Contexto do Projeto
- **Stack:** Python 3.11+, httpx (async), beautifulsoup4 + lxml, pandas, polars,
  pydantic v2, DuckDB, structlog, chardet
- **Arquitetura:** MÃ³dulos por fonte (cepea/, conab/, ibge/), cache DuckDB com
  histÃ³rico permanente, normalizaÃ§Ã£o centralizada, async-first, multi-parser
- **PadrÃµes:** Google Style Guide, pytest + pytest-asyncio, mkdocs-material
- **Fontes:** CEPEA (preÃ§os), CONAB (safras/balanÃ§o), IBGE/SIDRA (PAM, LSPA)
- **ResiliÃªncia:** Fingerprinting de layout, validaÃ§Ã£o estatÃ­stica, golden tests,
  alertas multi-canal, fallback em cascata

# ComunicaÃ§Ã£o (Token Saving Mode)
- Sem preÃ¢mbulos ("Claro!", "Entendo") ou conclusÃµes genÃ©ricas
- Prefira bullet points, tabelas e Markdown estruturado
- Assuma conhecimento de: pandas, polars, scraping, async, agronegÃ³cio brasileiro
- Se pedido ambÃ­guo: perguntas de esclarecimento antes de processar

# Qualidade de CÃ³digo (checklist interno, nÃ£o verbalizar)
- Type hints obrigatÃ³rios (usar `from __future__ import annotations`)
- Pydantic v2 BaseModel para todos os dados externos (Indicador, Safra, etc.)
- ValidaÃ§Ã£o de inputs em funÃ§Ãµes pÃºblicas da API
- Try/except especÃ­fico: `httpx.HTTPError`, `ValueError`, nunca genÃ©rico
- Constantes em `agrobr/constants.py` (URLs, TTLs, mapeamentos)
- FunÃ§Ãµes > 30 linhas â†’ propor quebra
- Antes de criar helper â†’ verificar se jÃ¡ existe em utils/
- Edge cases obrigatÃ³rios: resposta vazia, layout mudou, timeout, encoding
- Docstring Google style em funÃ§Ãµes pÃºblicas
- structlog com JSON para todos os logs
- SEM COMENTÃRIOS NO CÃ“DIGO - cÃ³digo deve ser autoexplicativo

# Imports
- Preferir `from modulo import submodulo` sobre `from modulo.submodulo import Classe`
- Imports explÃ­citos facilitam mocking e deixam origem clara
- NÃ£o adicionar imports nÃ£o utilizados (incluindo __future__ se nÃ£o usar annotations)

# Cache
- Smart TTL para CEPEA (expira Ã s 18h, nÃ£o TTL fixo)
- Fontes sem Cloudflare: NotÃ­cias AgrÃ­colas como fallback padrÃ£o
- Browser fallback desabilitado por padrÃ£o (_use_browser = False)

# Testes
- Type hints `-> None` nÃ£o sÃ£o necessÃ¡rios em mÃ©todos de teste
- Um teste por cenÃ¡rio, mÃºltiplas asserÃ§Ãµes dentro sÃ£o ok
- setUp() para configuraÃ§Ã£o compartilhada, nÃ£o para cada teste
- Nomes descritivos: test_<funcionalidade>_<cenario> ou test_<funcionalidade> se Ãºnico

# PadrÃµes EspecÃ­ficos agrobr
- HTTP: sempre `httpx.AsyncClient` com timeout, retry exponential, user-agent rotativo
- Cache: DuckDB local com separaÃ§Ã£o cache/histÃ³rico, verificar antes de request
- Parsing: isolar em `parsers/` com versionamento, fingerprinting, fallback em cascata
- NormalizaÃ§Ã£o: usar `normalize/` para unidades, datas safra, UFs, encoding
- Encoding: fallback chain UTF-8 â†’ ISO-8859-1 â†’ Windows-1252 â†’ chardet
- Testes: VCR cassettes + golden data tests para requests; mocks para cache
- Erros: exceÃ§Ãµes tipadas (SourceUnavailable, ParseError, StaleDataWarning)
- Alertas: multi-canal (Slack, Discord, Email) para falhas crÃ­ticas
- ValidaÃ§Ã£o: estatÃ­stica (ranges histÃ³ricos) + estrutural (fingerprint)

# Entregas
- Scripts completos e funcionais na primeira tentativa
- CorreÃ§Ãµes: apenas bloco corrigido + contexto mÃ­nimo
- Novos mÃ³dulos: seguir estrutura existente (client â†’ parser â†’ models â†’ API pÃºblica)
- Mencionar dependÃªncias quando adicionar nova lib


================================================================================
PARTE 1: VISÃƒO GERAL
================================================================================

Objetivo:
Transformar o agrobr de "biblioteca funcional" para "infraestrutura de dados
de produÃ§Ã£o" com contratos, rastreabilidade e observabilidade.

PrincÃ­pios:
  - Confiabilidade: usuÃ¡rio sabe exatamente o que esperar
  - Rastreabilidade: toda informaÃ§Ã£o tem origem documentada
  - Reprodutibilidade: mesmos inputs = mesmos outputs
  - Profissionalismo: padrÃ£o enterprise, nÃ£o hobby project

Diferencial competitivo:
  - PouquÃ­ssimas libs open-source tÃªm contratos de estabilidade
  - Data lineage Ã© requisito para jornalismo/auditoria/academia
  - Modo determinÃ­stico Ã© killer feature para backtests


================================================================================
PARTE 2: ROADMAP DE VERSÃ•ES
================================================================================

fase 1 (v0.2.0) âœ… COMPLETA
------------------
  [x] agrobr doctor (CLI diagnÃ³stico) - agrobr/health/doctor.py
  [x] return_meta (data lineage) - MetaInfo em models.py + APIs
  [x] DocumentaÃ§Ã£o: proveniÃªncia das fontes - docs/sources/*.md
  [x] DocumentaÃ§Ã£o: resiliÃªncia operacional - docs/advanced/resilience.md
  [x] Testes: test_health/test_doctor.py, test_models.py

fase 2 (v0.3.0) âœ… COMPLETA
--------------
  [x] Stability Contract formal - contracts/__init__.py, cepea.py, conab.py, ibge.py
  [x] ValidaÃ§Ã£o semÃ¢ntica avanÃ§ada - validators/semantic.py
  [x] Changelog humano (nÃ£o sÃ³ commits) - CHANGELOG.md
  [x] Benchmark integrado - benchmark/__init__.py
  [x] Testes: test_contracts.py, test_semantic.py (39 testes)

fase 3 (v0.4.0) âœ… COMPLETA
----------------
  [x] Modo determinÃ­stico (snapshots) - config.py (set_mode, AgrobrConfig)
  [x] Snapshots histÃ³ricos - snapshots.py (create_snapshot, load_from_snapshot)
  [x] Export para formatos auditÃ¡veis - export.py (parquet, csv, json)
  [x] CLI: snapshot create/list/delete/use
  [x] Testes: 50 testes (test_config.py, test_snapshots.py, test_export.py)

fase 4 (v0.5.0) âœ… COMPLETA
----------------
  [x] Plugin system - plugins/__init__.py (SourcePlugin, ParserPlugin, ExporterPlugin, ValidatorPlugin)
  [x] API estÃ¡vel garantida - stability.py (@stable, @experimental, @deprecated, @internal)
  [x] SLA documentado - sla.py (SourceSLA, CEPEA_SLA, CONAB_SLA, IBGE_SLA)
  [x] CertificaÃ§Ã£o de qualidade - quality.py (certify, QualityCertificate, QualityLevel)
  [x] Testes: 55 testes (test_plugins.py, test_stability.py, test_sla.py, test_quality.py)


================================================================================
PARTE 3: AGROBR DOCTOR (v0.2.0)
================================================================================

DESCRIÃ‡ÃƒO
---------
Comando CLI que diagnostica saÃºde do sistema, conectividade das fontes,
estado do cache e Ãºltimas coletas. Essencial para debugging e suporte.


EXEMPLO DE USO
--------------

$ agrobr doctor

ðŸ” agrobr diagnostics v0.2.0
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ðŸ“¡ Sources Connectivity
  âœ“ CEPEA (via NotÃ­cias AgrÃ­colas)  142ms  OK
  âœ“ CONAB                           89ms   OK
  âœ“ IBGE/SIDRA                      67ms   OK

ðŸ’¾ Cache Status
  Location:     ~/.agrobr/cache/agrobr_cache.duckdb
  Size:         2.4 MB
  Total records: 1,247

  By source:
    CEPEA:  847 records (2025-01-21 to 2026-02-04)
    CONAB:  305 records (2024-01-01 to 2026-02-04)
    IBGE:   95 records  (2020-01-01 to 2023-12-31)

ðŸ“Š Last Collection
  CEPEA:  2026-02-04 08:24:36 (10 new records)
  CONAB:  2026-02-04 08:34:12 (30 new records)
  IBGE:   2026-02-04 08:35:01 (95 new records)

â° Cache Expiry (Smart TTL)
  CEPEA:  Expires at 18:00 today (in 9h 35m)
  CONAB:  Expires in 15h 25m
  IBGE:   Expires in 6d 15h

ðŸ”§ Configuration
  Browser fallback: disabled
  Alternative source: enabled
  Log level: INFO

âœ… All systems operational


IMPLEMENTAÃ‡ÃƒO
-------------

# agrobr/cli.py (adicionar comando)

@app.command()
def doctor(
    verbose: bool = typer.Option(False, "--verbose", "-v", help="Show detailed info"),
    json_output: bool = typer.Option(False, "--json", help="Output as JSON"),
) -> None:
    """Diagnose agrobr health and connectivity."""
    from agrobr.health.doctor import run_diagnostics
    
    result = run_diagnostics(verbose=verbose)
    
    if json_output:
        console.print_json(data=result.to_dict())
    else:
        console.print(result.to_rich())


# agrobr/health/doctor.py (novo arquivo)

from __future__ import annotations

import time
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path
from typing import Any

import httpx
import structlog

from agrobr import constants
from agrobr.cache.duckdb_store import get_store
from agrobr.cache.policies import get_next_update_info

logger = structlog.get_logger()


@dataclass
class SourceStatus:
    """Status de uma fonte."""
    name: str
    url: str
    status: str  # "ok", "slow", "error"
    latency_ms: int
    error: str | None = None


@dataclass
class CacheStats:
    """EstatÃ­sticas do cache."""
    location: str
    size_bytes: int
    total_records: int
    by_source: dict[str, dict[str, Any]] = field(default_factory=dict)


@dataclass
class DiagnosticsResult:
    """Resultado do diagnÃ³stico completo."""
    version: str
    timestamp: datetime
    sources: list[SourceStatus]
    cache: CacheStats
    last_collections: dict[str, datetime]
    cache_expiry: dict[str, str]
    config: dict[str, Any]
    overall_status: str  # "healthy", "degraded", "error"
    
    def to_dict(self) -> dict[str, Any]:
        """Converte para dicionÃ¡rio."""
        return {
            "version": self.version,
            "timestamp": self.timestamp.isoformat(),
            "sources": [
                {
                    "name": s.name,
                    "status": s.status,
                    "latency_ms": s.latency_ms,
                    "error": s.error,
                }
                for s in self.sources
            ],
            "cache": {
                "location": self.cache.location,
                "size_mb": round(self.cache.size_bytes / 1024 / 1024, 2),
                "total_records": self.cache.total_records,
                "by_source": self.cache.by_source,
            },
            "last_collections": {
                k: v.isoformat() for k, v in self.last_collections.items()
            },
            "overall_status": self.overall_status,
        }
    
    def to_rich(self) -> str:
        """Formata para output rich no terminal."""
        from rich.console import Console
        from rich.table import Table
        from rich.panel import Panel
        
        # Implementar formataÃ§Ã£o rica
        # ...
        pass


async def _check_source(name: str, url: str, timeout: float = 10.0) -> SourceStatus:
    """Verifica conectividade de uma fonte."""
    start = time.perf_counter()
    
    try:
        async with httpx.AsyncClient(timeout=timeout) as client:
            response = await client.head(url, follow_redirects=True)
            latency_ms = int((time.perf_counter() - start) * 1000)
            
            if response.status_code < 400:
                status = "ok" if latency_ms < 1000 else "slow"
                return SourceStatus(name, url, status, latency_ms)
            else:
                return SourceStatus(
                    name, url, "error", latency_ms,
                    error=f"HTTP {response.status_code}"
                )
    except Exception as e:
        latency_ms = int((time.perf_counter() - start) * 1000)
        return SourceStatus(name, url, "error", latency_ms, error=str(e))


def _get_cache_stats() -> CacheStats:
    """ObtÃ©m estatÃ­sticas do cache."""
    store = get_store()
    cache_path = Path(store.db_path)
    
    size_bytes = cache_path.stat().st_size if cache_path.exists() else 0
    
    # Query por fonte
    by_source = {}
    for fonte in ["cepea", "conab", "ibge"]:
        try:
            records = store.conn.execute(
                "SELECT COUNT(*), MIN(data), MAX(data) FROM indicadores WHERE fonte = ?",
                [fonte]
            ).fetchone()
            if records and records[0] > 0:
                by_source[fonte] = {
                    "count": records[0],
                    "oldest": records[1],
                    "newest": records[2],
                }
        except Exception:
            pass
    
    total_records = sum(s.get("count", 0) for s in by_source.values())
    
    return CacheStats(
        location=str(cache_path),
        size_bytes=size_bytes,
        total_records=total_records,
        by_source=by_source,
    )


async def run_diagnostics(verbose: bool = False) -> DiagnosticsResult:
    """Executa diagnÃ³stico completo."""
    import agrobr
    
    # Check sources
    sources_to_check = [
        ("CEPEA (NotÃ­cias AgrÃ­colas)", "https://www.noticiasagricolas.com.br"),
        ("CONAB", "https://www.conab.gov.br"),
        ("IBGE/SIDRA", "https://sidra.ibge.gov.br"),
    ]
    
    sources = []
    for name, url in sources_to_check:
        status = await _check_source(name, url)
        sources.append(status)
    
    # Cache stats
    cache = _get_cache_stats()
    
    # Cache expiry info
    cache_expiry = {}
    for fonte in ["cepea", "conab", "ibge"]:
        info = get_next_update_info(fonte)
        cache_expiry[fonte] = info.get("expires_at") or info.get("ttl", "unknown")
    
    # Overall status
    error_count = sum(1 for s in sources if s.status == "error")
    if error_count == len(sources):
        overall_status = "error"
    elif error_count > 0:
        overall_status = "degraded"
    else:
        overall_status = "healthy"
    
    return DiagnosticsResult(
        version=agrobr.__version__,
        timestamp=datetime.now(),
        sources=sources,
        cache=cache,
        last_collections={},  # TODO: implementar tracking
        cache_expiry=cache_expiry,
        config={
            "browser_fallback": False,
            "alternative_source": True,
        },
        overall_status=overall_status,
    )


================================================================================
PARTE 4: DATA LINEAGE - RETURN_META (v0.2.0)
================================================================================

DESCRIÃ‡ÃƒO
---------
Toda chamada pode retornar, opcionalmente, um objeto de metadados com
informaÃ§Ãµes completas de proveniÃªncia, rastreabilidade e auditoria.


EXEMPLO DE USO
--------------

# Uso bÃ¡sico (sem mudanÃ§a)
df = await cepea.indicador('soja')

# Com metadados
df, meta = await cepea.indicador('soja', return_meta=True)

print(meta)
# MetaInfo(
#     source='noticias_agricolas',
#     source_url='https://www.noticiasagricolas.com.br/cotacoes/soja/...',
#     fetched_at=datetime(2026, 2, 4, 8, 24, 36),
#     from_cache=False,
#     cache_key='cepea:soja:paranagua',
#     cache_expires_at=datetime(2026, 2, 4, 18, 0, 0),
#     raw_content_hash='sha256:a3f2b1c4d5e6f7...',
#     raw_content_size=156432,
#     parse_duration_ms=45,
#     fetch_duration_ms=892,
#     records_count=10,
#     agrobr_version='0.2.0',
#     schema_version='1.0',
#     python_version='3.11.5',
#     timestamp=datetime(2026, 2, 4, 8, 24, 37),
# )

# Serializar para auditoria
meta.to_json()  # JSON string
meta.to_dict()  # Python dict

# Verificar integridade
meta.verify_hash(df)  # True se dados nÃ£o foram alterados


IMPLEMENTAÃ‡ÃƒO
-------------

# agrobr/models.py (adicionar)

from __future__ import annotations

import hashlib
import json
from dataclasses import dataclass, field
from datetime import datetime
from typing import Any, TYPE_CHECKING

if TYPE_CHECKING:
    import pandas as pd


@dataclass
class MetaInfo:
    """Metadados de proveniÃªncia e rastreabilidade."""
    
    # Fonte
    source: str                          # "cepea", "noticias_agricolas", "conab", "ibge"
    source_url: str                      # URL exata acessada
    source_method: str                   # "httpx", "playwright", "cache"
    
    # Timing
    fetched_at: datetime                 # Quando foi buscado
    timestamp: datetime = field(         # Quando este meta foi criado
        default_factory=datetime.now
    )
    fetch_duration_ms: int = 0           # Tempo de fetch
    parse_duration_ms: int = 0           # Tempo de parsing
    
    # Cache
    from_cache: bool = False             # Se veio do cache
    cache_key: str | None = None         # Chave no cache
    cache_expires_at: datetime | None = None  # Quando expira
    
    # Integridade
    raw_content_hash: str | None = None  # SHA256 do conteÃºdo bruto
    raw_content_size: int = 0            # Tamanho em bytes
    
    # Resultado
    records_count: int = 0               # Quantidade de registros
    columns: list[str] = field(default_factory=list)  # Colunas retornadas
    
    # VersÃµes
    agrobr_version: str = ""             # VersÃ£o do agrobr
    schema_version: str = "1.0"          # VersÃ£o do schema
    parser_version: int = 1              # VersÃ£o do parser usado
    python_version: str = ""             # VersÃ£o do Python
    
    # ValidaÃ§Ã£o
    validation_passed: bool = True       # Se passou validaÃ§Ã£o
    validation_warnings: list[str] = field(default_factory=list)
    
    def __post_init__(self) -> None:
        """Preenche versÃµes automaticamente."""
        if not self.agrobr_version:
            import agrobr
            self.agrobr_version = getattr(agrobr, "__version__", "unknown")
        
        if not self.python_version:
            import sys
            self.python_version = sys.version.split()[0]
    
    def to_dict(self) -> dict[str, Any]:
        """Converte para dicionÃ¡rio serializÃ¡vel."""
        return {
            "source": self.source,
            "source_url": self.source_url,
            "source_method": self.source_method,
            "fetched_at": self.fetched_at.isoformat(),
            "timestamp": self.timestamp.isoformat(),
            "fetch_duration_ms": self.fetch_duration_ms,
            "parse_duration_ms": self.parse_duration_ms,
            "from_cache": self.from_cache,
            "cache_key": self.cache_key,
            "cache_expires_at": (
                self.cache_expires_at.isoformat() 
                if self.cache_expires_at else None
            ),
            "raw_content_hash": self.raw_content_hash,
            "raw_content_size": self.raw_content_size,
            "records_count": self.records_count,
            "columns": self.columns,
            "agrobr_version": self.agrobr_version,
            "schema_version": self.schema_version,
            "parser_version": self.parser_version,
            "python_version": self.python_version,
            "validation_passed": self.validation_passed,
            "validation_warnings": self.validation_warnings,
        }
    
    def to_json(self, indent: int = 2) -> str:
        """Serializa para JSON."""
        return json.dumps(self.to_dict(), indent=indent, ensure_ascii=False)
    
    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> MetaInfo:
        """ReconstrÃ³i a partir de dicionÃ¡rio."""
        data = data.copy()
        
        # Converter strings ISO para datetime
        for key in ["fetched_at", "timestamp", "cache_expires_at"]:
            if data.get(key) and isinstance(data[key], str):
                data[key] = datetime.fromisoformat(data[key])
        
        return cls(**data)
    
    def compute_dataframe_hash(self, df: pd.DataFrame) -> str:
        """Computa hash do DataFrame para verificaÃ§Ã£o."""
        import pandas as pd
        
        # Serializa DataFrame de forma determinÃ­stica
        csv_bytes = df.to_csv(index=False).encode("utf-8")
        return f"sha256:{hashlib.sha256(csv_bytes).hexdigest()}"
    
    def verify_hash(self, df: pd.DataFrame) -> bool:
        """Verifica se DataFrame corresponde ao hash original."""
        if not self.raw_content_hash:
            return True  # Sem hash para verificar
        
        current_hash = self.compute_dataframe_hash(df)
        return current_hash == self.raw_content_hash


ATUALIZAÃ‡ÃƒO DA API
------------------

# agrobr/cepea/api.py (modificar assinatura)

from typing import overload, Literal

@overload
async def indicador(
    produto: str,
    *,
    return_meta: Literal[False] = False,
    **kwargs,
) -> pd.DataFrame: ...

@overload
async def indicador(
    produto: str,
    *,
    return_meta: Literal[True],
    **kwargs,
) -> tuple[pd.DataFrame, MetaInfo]: ...

async def indicador(
    produto: str,
    praca: str | None = None,
    inicio: str | date | None = None,
    fim: str | date | None = None,
    moeda: str = "BRL",
    as_polars: bool = False,
    validate_sanity: bool = False,
    force_refresh: bool = False,
    offline: bool = False,
    return_meta: bool = False,  # NOVO PARÃ‚METRO
) -> pd.DataFrame | tuple[pd.DataFrame, MetaInfo]:
    """
    ObtÃ©m sÃ©rie de indicadores de preÃ§o do CEPEA.
    
    Args:
        ...
        return_meta: Se True, retorna tupla (DataFrame, MetaInfo)
    
    Returns:
        DataFrame ou tupla (DataFrame, MetaInfo) se return_meta=True
    """
    
    # InÃ­cio do tracking
    fetch_start = time.perf_counter()
    meta = MetaInfo(
        source="unknown",
        source_url="",
        source_method="unknown",
        fetched_at=datetime.now(),
    )
    
    # ... lÃ³gica existente ...
    
    # Atualizar meta durante execuÃ§Ã£o
    meta.source = "noticias_agricolas"  # ou "cepea", "cache"
    meta.source_url = url
    meta.source_method = "httpx"  # ou "playwright", "cache"
    meta.from_cache = from_cache
    meta.fetch_duration_ms = int((time.perf_counter() - fetch_start) * 1000)
    meta.records_count = len(df)
    meta.columns = df.columns.tolist()
    
    # Retorno
    if return_meta:
        return df, meta
    return df


================================================================================
PARTE 5: DOCUMENTAÃ‡ÃƒO - PROVENIÃŠNCIA DAS FONTES (v0.2.0)
================================================================================

ARQUIVO: docs/sources/index.md
------------------------------

# Fontes de Dados

O agrobr integra dados de trÃªs fontes oficiais brasileiras:

| Fonte | Tipo | AtualizaÃ§Ã£o | Cobertura |
|-------|------|-------------|-----------|
| CEPEA/ESALQ | PreÃ§os | DiÃ¡ria | Commodities agrÃ­colas |
| CONAB | Safras | Mensal | ProduÃ§Ã£o nacional |
| IBGE | EstatÃ­sticas | Anual/Mensal | Dados oficiais |

## ProveniÃªncia e Rastreabilidade

Toda informaÃ§Ã£o retornada pelo agrobr pode ser rastreada atÃ© sua origem.
Use `return_meta=True` para obter metadados completos.


ARQUIVO: docs/sources/cepea.md
------------------------------

# CEPEA - Centro de Estudos AvanÃ§ados em Economia Aplicada

## VisÃ£o Geral

| Campo | Valor |
|-------|-------|
| **InstituiÃ§Ã£o** | ESALQ/USP |
| **Website** | [cepea.esalq.usp.br](https://www.cepea.esalq.usp.br) |
| **Acesso agrobr** | Via NotÃ­cias AgrÃ­colas (mirror autorizado) |

## Origem dos Dados

### Fonte PrimÃ¡ria
- **URL oficial**: `https://www.cepea.esalq.usp.br/br/indicador/soja.aspx`
- **Status**: Bloqueado por Cloudflare (acesso programÃ¡tico negado)

### Fonte Alternativa (atual)
- **URL**: `https://www.noticiasagricolas.com.br/cotacoes/{produto}/`
- **Tipo**: Mirror autorizado dos indicadores CEPEA
- **Status**: âœ… Funcional

## Produtos DisponÃ­veis

| Produto | PraÃ§a Principal | Unidade | FrequÃªncia |
|---------|-----------------|---------|------------|
| Soja | ParanaguÃ¡/PR | BRL/sc 60kg | DiÃ¡ria |
| Milho | Campinas/SP | BRL/sc 60kg | DiÃ¡ria |
| Boi Gordo | SÃ£o Paulo/SP | BRL/@ | DiÃ¡ria |
| CafÃ© ArÃ¡bica | SÃ£o Paulo/SP | BRL/sc 60kg | DiÃ¡ria |
| Trigo | ParanÃ¡ | BRL/ton | DiÃ¡ria |
| AlgodÃ£o | SÃ£o Paulo/SP | BRL/@ | DiÃ¡ria |

## Metodologia CEPEA

O CEPEA calcula indicadores baseado em:
- Pesquisa diÃ¡ria com agentes de mercado
- MÃ©dia ponderada por volume negociado
- Ajuste para qualidade padrÃ£o

Fonte: [Metodologia CEPEA](https://www.cepea.esalq.usp.br/br/metodologia.aspx)

## AtualizaÃ§Ã£o e Defasagem

| Aspecto | Valor |
|---------|-------|
| **HorÃ¡rio de atualizaÃ§Ã£o** | ~17:00 - 18:00 (dias Ãºteis) |
| **Defasagem tÃ­pica** | D+0 (mesmo dia) |
| **Dias sem publicaÃ§Ã£o** | Fins de semana, feriados nacionais |
| **Cache agrobr** | Expira Ã s 18:00 (Smart TTL) |

## Schema dos Dados

```python
@dataclass
class IndicadorCEPEA:
    data: date              # Data do indicador
    produto: str            # Nome do produto
    praca: str | None       # PraÃ§a de referÃªncia
    valor: Decimal          # PreÃ§o em BRL
    unidade: str            # Ex: "BRL/sc60kg"
    variacao: float | None  # VariaÃ§Ã£o % dia anterior
    fonte: str              # "cepea" ou "noticias_agricolas"
    metodologia: str        # "CEPEA/ESALQ via NotÃ­cias AgrÃ­colas"
```

## Exemplo com Metadados

```python
df, meta = await cepea.indicador('soja', return_meta=True)

print(meta.source)      # "noticias_agricolas"
print(meta.source_url)  # "https://www.noticiasagricolas.com.br/..."
print(meta.fetched_at)  # datetime(2026, 2, 4, 8, 24, 36)
```


ARQUIVO: docs/sources/conab.md
------------------------------

# CONAB - Companhia Nacional de Abastecimento

## VisÃ£o Geral

| Campo | Valor |
|-------|-------|
| **InstituiÃ§Ã£o** | MinistÃ©rio da Agricultura |
| **Website** | [conab.gov.br](https://www.conab.gov.br) |
| **Acesso agrobr** | Direto (XLSX pÃºblicos) |

## Origem dos Dados

### Fonte
- **URL**: `https://www.conab.gov.br/info-agro/safras/graos`
- **Formato**: XLSX (planilhas Excel)
- **Acesso**: âœ… PÃºblico, sem restriÃ§Ãµes

## Levantamentos

A CONAB publica levantamentos mensais de safra:

| MÃªs | Levantamento |
|-----|--------------|
| Outubro | 1Âº Levantamento |
| Novembro | 2Âº Levantamento |
| Dezembro | 3Âº Levantamento |
| ... | ... |
| Setembro | 12Âº Levantamento |

## Dados DisponÃ­veis

### Safras
- Ãrea plantada (mil hectares)
- Ãrea colhida (mil hectares)
- Produtividade (kg/ha)
- ProduÃ§Ã£o (mil toneladas)

### BalanÃ§o de Oferta e Demanda
- Estoque inicial
- ProduÃ§Ã£o
- ImportaÃ§Ã£o
- Consumo
- ExportaÃ§Ã£o
- Estoque final

## Schema dos Dados

```python
@dataclass
class SafraCONAB:
    fonte: str              # "conab"
    produto: str            # Ex: "soja"
    safra: str              # Ex: "2024/25"
    uf: str                 # Ex: "MT", "PR"
    area_plantada: float    # mil hectares
    area_colhida: float     # mil hectares
    produtividade: float    # kg/ha
    producao: float         # mil toneladas
    data_publicacao: date   # Data do levantamento
```

## AtualizaÃ§Ã£o

| Aspecto | Valor |
|---------|-------|
| **FrequÃªncia** | Mensal |
| **PublicaÃ§Ã£o** | Geralmente entre dias 10-15 |
| **Cache agrobr** | 24 horas |


ARQUIVO: docs/sources/ibge.md
-----------------------------

# IBGE - Instituto Brasileiro de Geografia e EstatÃ­stica

## VisÃ£o Geral

| Campo | Valor |
|-------|-------|
| **InstituiÃ§Ã£o** | Governo Federal |
| **Website** | [ibge.gov.br](https://www.ibge.gov.br) |
| **API** | [SIDRA](https://sidra.ibge.gov.br) |
| **Acesso agrobr** | Via API SIDRA (JSON) |

## Origem dos Dados

### Fonte
- **API**: `https://sidra.ibge.gov.br/`
- **Formato**: JSON
- **Acesso**: âœ… PÃºblico, sem autenticaÃ§Ã£o

## Pesquisas DisponÃ­veis

### PAM - ProduÃ§Ã£o AgrÃ­cola Municipal
- **Tabela SIDRA**: 5457 (nova sÃ©rie 2018+)
- **Cobertura**: Todos os municÃ­pios
- **FrequÃªncia**: Anual

### LSPA - Levantamento SistemÃ¡tico da ProduÃ§Ã£o AgrÃ­cola
- **Tabela SIDRA**: 6588
- **Cobertura**: Nacional/UF
- **FrequÃªncia**: Mensal

## VariÃ¡veis

| CÃ³digo | Nome | Unidade |
|--------|------|---------|
| 214 | Ãrea plantada | hectares |
| 215 | Ãrea colhida | hectares |
| 216 | Quantidade produzida | toneladas |
| 112 | Rendimento mÃ©dio | kg/ha |

## Schema dos Dados

```python
@dataclass
class DadosPAM:
    ano: int                # Ano de referÃªncia
    produto: str            # Ex: "soja"
    localidade: str         # Nome do municÃ­pio/UF
    cod_ibge: int           # CÃ³digo IBGE
    area_plantada: float    # hectares
    area_colhida: float     # hectares
    producao: float         # toneladas
    rendimento: float       # kg/ha
    valor_producao: float   # mil reais
```

## AtualizaÃ§Ã£o

| Pesquisa | FrequÃªncia | Cache agrobr |
|----------|------------|--------------|
| PAM | Anual (agosto-setembro) | 7 dias |
| LSPA | Mensal | 24 horas |


================================================================================
PARTE 6: DOCUMENTAÃ‡ÃƒO - RESILIÃŠNCIA OPERACIONAL (v0.2.0)
================================================================================

ARQUIVO: docs/advanced/resilience.md
------------------------------------

# ResiliÃªncia Operacional

O agrobr foi projetado para operar de forma confiÃ¡vel mesmo quando
fontes de dados estÃ£o instÃ¡veis ou indisponÃ­veis.

## Rate Limits

Para proteger as fontes e evitar bloqueios:

| Fonte | Limite | Delay entre requests |
|-------|--------|---------------------|
| CEPEA/NotÃ­cias AgrÃ­colas | 30 req/min | 2 segundos |
| CONAB | 20 req/min | 3 segundos |
| IBGE/SIDRA | 60 req/min | 1 segundo |

### ConfiguraÃ§Ã£o

```python
from agrobr.http.rate_limiter import RateLimiter

# Ver configuraÃ§Ã£o atual
RateLimiter.get_config("cepea")

# Os limites sÃ£o gerenciados automaticamente
# NÃ£o Ã© necessÃ¡rio configurar manualmente
```

## PolÃ­tica de Retry

Quando uma requisiÃ§Ã£o falha, o agrobr tenta novamente:

| ParÃ¢metro | Valor |
|-----------|-------|
| MÃ¡ximo de tentativas | 3 |
| Backoff inicial | 1 segundo |
| Backoff mÃ¡ximo | 30 segundos |
| Fator multiplicador | 2x (exponencial) |

### Status codes que acionam retry

- 408 Request Timeout
- 429 Too Many Requests
- 500 Internal Server Error
- 502 Bad Gateway
- 503 Service Unavailable
- 504 Gateway Timeout

## Cache e TTL

### Smart TTL (CEPEA)

O CEPEA atualiza indicadores por volta das 17-18h.
O cache expira automaticamente Ã s 18:00:

```
08:00 - Busca soja â†’ Cache vÃ¡lido atÃ© 18:00
10:00 - Busca soja â†’ Usa cache
17:59 - Busca soja â†’ Usa cache
18:01 - Busca soja â†’ Cache expirou â†’ Busca fonte â†’ VÃ¡lido atÃ© 18:00 amanhÃ£
```

### TTL por Fonte

| Fonte | TTL | Stale mÃ¡ximo |
|-------|-----|--------------|
| CEPEA | Smart (18h) | 48 horas |
| CONAB | 24 horas | 30 dias |
| IBGE/PAM | 7 dias | 90 dias |
| IBGE/LSPA | 24 horas | 30 dias |

### Comportamento com Cache Stale

Quando a fonte estÃ¡ indisponÃ­vel mas existe cache (mesmo expirado):

| SituaÃ§Ã£o | Comportamento | Retorno |
|----------|---------------|---------|
| Fonte OK, cache fresh | Usa cache | DataFrame |
| Fonte OK, cache expirado | Busca fonte, atualiza cache | DataFrame |
| Fonte ERRO, cache fresh | Usa cache | DataFrame |
| Fonte ERRO, cache stale | Usa cache + warning | DataFrame + `StaleDataWarning` |
| Fonte ERRO, sem cache | Levanta exceÃ§Ã£o | `SourceUnavailableError` |

## Cadeia de Fallback

### CEPEA

```
1. httpx direto para NotÃ­cias AgrÃ­colas
      â†“ (se falhar)
2. Cache local (DuckDB)
      â†“ (se nÃ£o existir)
3. SourceUnavailableError
```

Nota: O fallback para browser (Playwright) estÃ¡ desabilitado
devido a bloqueio Cloudflare.

### CONAB

```
1. Download XLSX via httpx
      â†“ (se falhar)
2. Playwright (sites com JavaScript)
      â†“ (se falhar)
3. Cache local
      â†“ (se nÃ£o existir)
4. SourceUnavailableError
```

### IBGE

```
1. API SIDRA (JSON)
      â†“ (se falhar)
2. Cache local
      â†“ (se nÃ£o existir)
3. SourceUnavailableError
```

## Fingerprinting de Layout

O agrobr detecta mudanÃ§as no layout das pÃ¡ginas fonte:

### Como funciona

1. **ExtraÃ§Ã£o**: Ao parsear, extrai "fingerprint" da estrutura HTML
   - Quantidade de tabelas
   - Classes CSS principais
   - Estrutura de colunas

2. **ComparaÃ§Ã£o**: Compara com baseline salvo

3. **Alerta**: Se fingerprint mudou significativamente:
   - Log WARNING
   - Tenta parsers alternativos
   - Notifica se configurado

### O que fazer quando layout muda

1. Verifique se os dados retornados estÃ£o corretos
2. Se incorretos, abra issue no GitHub
3. Atualize para Ãºltima versÃ£o do agrobr (pode ter fix)

## ExceÃ§Ãµes

| ExceÃ§Ã£o | Causa | O que fazer |
|---------|-------|-------------|
| `SourceUnavailableError` | Fonte offline, sem cache | Aguardar, tentar depois |
| `ParseError` | Layout mudou, parser falhou | Atualizar agrobr, abrir issue |
| `ValidationError` | Dados fora do esperado | Verificar fonte original |
| `StaleDataWarning` | Usando cache antigo | Informativo, dados podem estar desatualizados |

## DiagnÃ³stico

Use o comando `doctor` para verificar saÃºde do sistema:

```bash
agrobr doctor
```

Retorna:
- Status de conectividade das fontes
- EstatÃ­sticas do cache
- Ãšltimas coletas
- ConfiguraÃ§Ã£o atual


================================================================================
PARTE 7: STABILITY CONTRACT (v0.3.0)
================================================================================

CONCEITO
--------

Um Stability Contract Ã© uma garantia formal de que:
- Nomes de colunas nÃ£o mudam (novas colunas sÃ³ adicionam)
- Tipos sÃ³ podem "alargar" (intâ†’float, strâ†’categorical)
- Datas sempre UTC ISO-8601
- Unidades explÃ­citas

Isso permite que usuÃ¡rios versionem pipelines sem medo de quebra.


IMPLEMENTAÃ‡ÃƒO
-------------

# agrobr/contracts/__init__.py

from __future__ import annotations

from dataclasses import dataclass, field
from enum import StrEnum
from typing import Any, Literal

import pandas as pd


class ColumnType(StrEnum):
    """Tipos de dados suportados."""
    DATE = "date"
    DATETIME = "datetime"
    STRING = "str"
    INTEGER = "int"
    FLOAT = "float"
    DECIMAL = "Decimal"
    BOOLEAN = "bool"


class BreakingChangePolicy(StrEnum):
    """PolÃ­tica para mudanÃ§as que quebram contrato."""
    MAJOR_VERSION = "major"      # SÃ³ em versÃ£o major (1.0â†’2.0)
    NEVER = "never"              # Nunca quebra
    DEPRECATE_FIRST = "deprecate"  # Depreca antes de remover


@dataclass
class Column:
    """DefiniÃ§Ã£o de uma coluna no contrato."""
    name: str
    type: ColumnType
    nullable: bool = False
    unit: str | None = None
    description: str = ""
    stable: bool = True          # Se False, pode mudar entre versÃµes
    deprecated: bool = False
    deprecated_in: str | None = None
    removed_in: str | None = None
    
    def validate(self, series: pd.Series) -> list[str]:
        """Valida uma sÃ©rie contra esta definiÃ§Ã£o."""
        errors = []
        
        # Check nullability
        if not self.nullable and series.isna().any():
            errors.append(f"Column '{self.name}' has null values but nullable=False")
        
        # Check type (bÃ¡sico)
        # TODO: validaÃ§Ã£o mais sofisticada
        
        return errors


@dataclass
class Contract:
    """Contrato de estabilidade para um dataset."""
    
    name: str                    # Ex: "cepea.indicador"
    version: str                 # Ex: "1.0"
    columns: list[Column]
    guarantees: list[str] = field(default_factory=list)
    breaking_policy: BreakingChangePolicy = BreakingChangePolicy.MAJOR_VERSION
    effective_from: str = ""     # VersÃ£o do agrobr
    
    def validate(self, df: pd.DataFrame) -> tuple[bool, list[str]]:
        """
        Valida DataFrame contra o contrato.
        
        Returns:
            Tupla (vÃ¡lido, lista de erros)
        """
        errors = []
        
        # Check required columns exist
        required_cols = [c.name for c in self.columns if not c.nullable and c.stable]
        missing = set(required_cols) - set(df.columns)
        if missing:
            errors.append(f"Missing required columns: {missing}")
        
        # Validate each column
        for col_def in self.columns:
            if col_def.name in df.columns:
                col_errors = col_def.validate(df[col_def.name])
                errors.extend(col_errors)
        
        return len(errors) == 0, errors
    
    def to_markdown(self) -> str:
        """Gera documentaÃ§Ã£o Markdown do contrato."""
        lines = [
            f"# Contract: {self.name}",
            f"**Version:** {self.version}",
            "",
            "## Columns",
            "",
            "| Column | Type | Nullable | Unit | Stable |",
            "|--------|------|----------|------|--------|",
        ]
        
        for col in self.columns:
            stable = "âœ“" if col.stable else "âœ—"
            nullable = "âœ“" if col.nullable else "âœ—"
            unit = col.unit or "-"
            lines.append(f"| {col.name} | {col.type} | {nullable} | {unit} | {stable} |")
        
        if self.guarantees:
            lines.extend(["", "## Guarantees", ""])
            for g in self.guarantees:
                lines.append(f"- {g}")
        
        return "\n".join(lines)


CONTRATOS DEFINIDOS
-------------------

# agrobr/contracts/cepea.py

from agrobr.contracts import Contract, Column, ColumnType, BreakingChangePolicy

CEPEA_INDICADOR_V1 = Contract(
    name="cepea.indicador",
    version="1.0",
    effective_from="0.3.0",
    columns=[
        Column(
            name="data",
            type=ColumnType.DATE,
            nullable=False,
            stable=True,
            description="Data do indicador",
        ),
        Column(
            name="produto",
            type=ColumnType.STRING,
            nullable=False,
            stable=True,
            description="Nome do produto (soja, milho, etc)",
        ),
        Column(
            name="praca",
            type=ColumnType.STRING,
            nullable=True,
            stable=True,
            description="PraÃ§a de referÃªncia",
        ),
        Column(
            name="valor",
            type=ColumnType.DECIMAL,
            nullable=False,
            unit="BRL",
            stable=True,
            description="PreÃ§o em reais",
        ),
        Column(
            name="unidade",
            type=ColumnType.STRING,
            nullable=False,
            stable=True,
            description="Unidade do preÃ§o (BRL/sc60kg, BRL/@, etc)",
        ),
        Column(
            name="variacao",
            type=ColumnType.FLOAT,
            nullable=True,
            stable=False,
            description="VariaÃ§Ã£o percentual (pode nÃ£o estar disponÃ­vel)",
        ),
        Column(
            name="fonte",
            type=ColumnType.STRING,
            nullable=False,
            stable=True,
            description="Fonte dos dados",
        ),
        Column(
            name="metodologia",
            type=ColumnType.STRING,
            nullable=True,
            stable=False,
            description="DescriÃ§Ã£o da metodologia",
        ),
    ],
    guarantees=[
        "Column names never change (additions only)",
        "Types only widen (intâ†’float, strâ†’categorical)",
        "Dates always in local timezone (SÃ£o Paulo)",
        "Units explicit in 'unidade' column",
        "'valor' is always positive",
        "'data' is always a valid business day",
    ],
    breaking_policy=BreakingChangePolicy.MAJOR_VERSION,
)


USO DO CONTRATO
---------------

from agrobr.contracts.cepea import CEPEA_INDICADOR_V1

# Validar DataFrame
df = await cepea.indicador('soja')
valid, errors = CEPEA_INDICADOR_V1.validate(df)

if not valid:
    print("Contract violations:", errors)

# Gerar documentaÃ§Ã£o
print(CEPEA_INDICADOR_V1.to_markdown())


================================================================================
PARTE 8: MODO DETERMINÃSTICO (v0.4.0)
================================================================================

CONCEITO
--------

Para backtests, papers e relatÃ³rios, reprodutibilidade absoluta Ã© essencial.
O modo determinÃ­stico garante que mesmas chamadas retornam mesmos resultados.


IMPLEMENTAÃ‡ÃƒO
-------------

# agrobr/config.py (novo arquivo)

from __future__ import annotations

from dataclasses import dataclass
from datetime import date
from typing import Literal

_config: AgrobConfig | None = None


@dataclass
class AgrobConfig:
    """ConfiguraÃ§Ã£o global do agrobr."""
    
    mode: Literal["normal", "deterministic"] = "normal"
    snapshot_date: date | None = None
    snapshot_path: str | None = None
    
    # Cache
    cache_enabled: bool = True
    cache_path: str | None = None
    
    # Network
    network_enabled: bool = True
    timeout_seconds: int = 30


def set_mode(
    mode: Literal["normal", "deterministic"],
    snapshot: str | date | None = None,
    snapshot_path: str | None = None,
) -> None:
    """
    Define modo de operaÃ§Ã£o do agrobr.
    
    Args:
        mode: "normal" ou "deterministic"
        snapshot: Data do snapshot (YYYY-MM-DD ou date)
        snapshot_path: Caminho para snapshots salvos
    
    Example:
        # Modo normal (padrÃ£o)
        agrobr.set_mode("normal")
        
        # Modo determinÃ­stico - sempre retorna mesmos dados
        agrobr.set_mode("deterministic", snapshot="2025-12-31")
    """
    global _config
    
    if isinstance(snapshot, str):
        snapshot = date.fromisoformat(snapshot)
    
    _config = AgrobConfig(
        mode=mode,
        snapshot_date=snapshot,
        snapshot_path=snapshot_path,
        network_enabled=(mode == "normal"),
    )


def get_config() -> AgrobConfig:
    """Retorna configuraÃ§Ã£o atual."""
    global _config
    if _config is None:
        _config = AgrobConfig()
    return _config


def reset_config() -> None:
    """Reseta para configuraÃ§Ã£o padrÃ£o."""
    global _config
    _config = None


COMPORTAMENTO
-------------

Modo normal (padrÃ£o):
  - Busca dados online
  - Atualiza cache
  - Retorna dados mais recentes

Modo determinÃ­stico:
  - NUNCA acessa rede
  - Usa apenas snapshots locais
  - Mesma chamada = mesmo resultado, sempre

Uso:
  
  import agrobr
  
  # Configurar modo determinÃ­stico
  agrobr.set_mode("deterministic", snapshot="2025-12-31")
  
  # Todas as chamadas usam dados do snapshot
  df = await cepea.indicador('soja')  # Sempre mesmo resultado
  
  # Voltar ao normal
  agrobr.set_mode("normal")


SNAPSHOTS
---------

Estrutura de snapshots:

~/.agrobr/snapshots/
â”œâ”€â”€ 2025-12-31/
â”‚   â”œâ”€â”€ cepea/
â”‚   â”‚   â”œâ”€â”€ soja.parquet
â”‚   â”‚   â”œâ”€â”€ milho.parquet
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ conab/
â”‚   â”‚   â””â”€â”€ safras.parquet
â”‚   â””â”€â”€ ibge/
â”‚       â”œâ”€â”€ pam.parquet
â”‚       â””â”€â”€ lspa.parquet
â”œâ”€â”€ 2026-01-15/
â”‚   â””â”€â”€ ...
â””â”€â”€ manifest.json

Criar snapshot:

  # CLI
  $ agrobr snapshot create --name 2025-12-31
  
  # Python
  from agrobr.snapshots import create_snapshot
  create_snapshot("2025-12-31")


================================================================================
PARTE 9: VALIDAÃ‡ÃƒO SEMÃ‚NTICA (v0.3.0)
================================================================================

CONCEITO
--------

AlÃ©m de validar tipos (schema), validar sentido econÃ´mico/agronÃ´mico:
  - PreÃ§o < 0 â†’ erro
  - Produtividade fora de faixa histÃ³rica â†’ warning
  - VariaÃ§Ã£o diÃ¡ria > 20% â†’ anomalia


IMPLEMENTAÃ‡ÃƒO
-------------

# agrobr/validators/semantic.py

from __future__ import annotations

from dataclasses import dataclass
from decimal import Decimal
from typing import Any

import pandas as pd
import structlog

logger = structlog.get_logger()


@dataclass
class SemanticRule:
    """Regra de validaÃ§Ã£o semÃ¢ntica."""
    name: str
    description: str
    severity: str  # "error", "warning", "info"
    
    def check(self, df: pd.DataFrame, **kwargs: Any) -> list[dict[str, Any]]:
        """Executa verificaÃ§Ã£o. Retorna lista de violaÃ§Ãµes."""
        raise NotImplementedError


class PricePositiveRule(SemanticRule):
    """PreÃ§o deve ser positivo."""
    
    def __init__(self) -> None:
        super().__init__(
            name="price_positive",
            description="Prices must be positive",
            severity="error",
        )
    
    def check(self, df: pd.DataFrame, **kwargs: Any) -> list[dict[str, Any]]:
        violations = []
        
        if "valor" in df.columns:
            negative = df[df["valor"] <= 0]
            for _, row in negative.iterrows():
                violations.append({
                    "rule": self.name,
                    "severity": self.severity,
                    "row": row.to_dict(),
                    "message": f"Negative price: {row['valor']}",
                })
        
        return violations


class ProductivityRangeRule(SemanticRule):
    """Produtividade deve estar em faixa razoÃ¡vel."""
    
    # Faixas histÃ³ricas por produto (kg/ha)
    RANGES = {
        "soja": (1500, 5000),
        "milho": (2000, 12000),
        "arroz": (3000, 8000),
        "trigo": (1500, 4500),
    }
    
    def __init__(self) -> None:
        super().__init__(
            name="productivity_range",
            description="Productivity must be within historical range",
            severity="warning",
        )
    
    def check(self, df: pd.DataFrame, **kwargs: Any) -> list[dict[str, Any]]:
        violations = []
        
        if "produtividade" not in df.columns or "produto" not in df.columns:
            return violations
        
        for _, row in df.iterrows():
            produto = row.get("produto", "").lower()
            produtividade = row.get("produtividade", 0)
            
            if produto in self.RANGES:
                min_val, max_val = self.RANGES[produto]
                if produtividade < min_val or produtividade > max_val:
                    violations.append({
                        "rule": self.name,
                        "severity": self.severity,
                        "row": row.to_dict(),
                        "message": f"Productivity {produtividade} outside range [{min_val}, {max_val}]",
                    })
        
        return violations


class DailyVariationRule(SemanticRule):
    """VariaÃ§Ã£o diÃ¡ria nÃ£o deve ser extrema."""
    
    MAX_VARIATION = 0.20  # 20%
    
    def __init__(self) -> None:
        super().__init__(
            name="daily_variation",
            description="Daily variation should not exceed 20%",
            severity="warning",
        )
    
    def check(self, df: pd.DataFrame, **kwargs: Any) -> list[dict[str, Any]]:
        violations = []
        
        if "variacao" not in df.columns:
            return violations
        
        extreme = df[df["variacao"].abs() > self.MAX_VARIATION * 100]
        for _, row in extreme.iterrows():
            violations.append({
                "rule": self.name,
                "severity": self.severity,
                "row": row.to_dict(),
                "message": f"Extreme variation: {row['variacao']}%",
            })
        
        return violations


# Regras padrÃ£o
DEFAULT_RULES = [
    PricePositiveRule(),
    ProductivityRangeRule(),
    DailyVariationRule(),
]


def validate_semantic(
    df: pd.DataFrame,
    rules: list[SemanticRule] | None = None,
    fail_on_error: bool = True,
) -> tuple[bool, list[dict[str, Any]]]:
    """
    Valida DataFrame semanticamente.
    
    Args:
        df: DataFrame a validar
        rules: Regras a aplicar (usa padrÃ£o se None)
        fail_on_error: Se True, levanta exceÃ§Ã£o em erros
    
    Returns:
        Tupla (vÃ¡lido, lista de violaÃ§Ãµes)
    """
    rules = rules or DEFAULT_RULES
    all_violations = []
    
    for rule in rules:
        violations = rule.check(df)
        all_violations.extend(violations)
        
        for v in violations:
            logger.log(
                v["severity"],
                "semantic_validation",
                rule=v["rule"],
                message=v["message"],
            )
    
    errors = [v for v in all_violations if v["severity"] == "error"]
    
    if errors and fail_on_error:
        from agrobr.exceptions import ValidationError
        raise ValidationError(
            source="semantic",
            reason=f"{len(errors)} semantic errors found",
            details=errors,
        )
    
    return len(errors) == 0, all_violations


================================================================================
PARTE 10: CHECKLIST DE IMPLEMENTAÃ‡ÃƒO
================================================================================


------ âœ… FASE 1 COMPLETA

[x] agrobr doctor
    [x] health/doctor.py - SourceStatus, CacheStats, DiagnosticsResult
    [x] Comando CLI - agrobr doctor
    [x] Teste de conectividade - _check_source() async
    [x] EstatÃ­sticas de cache - _get_cache_stats()
    [x] Output JSON e Rich - to_dict(), to_rich()
    [x] Testes: 10 testes (test_health/test_doctor.py)

[x] return_meta (data lineage)
    [x] MetaInfo dataclass - models.py
    [x] Atualizar cepea/api.py - return_meta=True
    [x] Atualizar conab/api.py - return_meta=True
    [x] Atualizar ibge/api.py - return_meta=True
    [x] Testes: 11 testes (test_models.py)

[x] DocumentaÃ§Ã£o proveniÃªncia
    [x] docs/sources/index.md
    [x] docs/sources/cepea.md
    [x] docs/sources/conab.md
    [x] docs/sources/ibge.md

[x] DocumentaÃ§Ã£o resiliÃªncia
    [x] docs/advanced/resilience.md
    [x] Rate limits
    [x] Retry policy
    [x] Cache TTL
    [x] Fallback chain


------ âœ… FASE 2 COMPLETA

[x] Stability Contract
    [x] contracts/__init__.py - Column, Contract, ColumnType, BreakingChangePolicy
    [x] contracts/cepea.py - CEPEA_INDICADOR_V1
    [x] contracts/conab.py - CONAB_SAFRA_V1, CONAB_BALANCO_V1
    [x] contracts/ibge.py - IBGE_PAM_V1, IBGE_LSPA_V1
    [x] ValidaÃ§Ã£o automÃ¡tica - contract.validate(df)
    [x] DocumentaÃ§Ã£o - to_markdown()

[x] ValidaÃ§Ã£o semÃ¢ntica
    [x] validators/semantic.py
    [x] Regras padrÃ£o (PricePositive, ProductivityRange, DailyVariation, etc.)
    [x] validate_semantic() + get_validation_summary()
    [x] Testes (19 testes)

[x] Changelog humano
    [x] CHANGELOG.md estruturado
    [x] Categorias: Added, Changed
    [x] VersÃµes 0.1.0, 0.2.0, 0.3.0

[x] Benchmark suite
    [x] benchmark/__init__.py - BenchmarkResult, BenchmarkSuite
    [x] benchmark_async(), benchmark_sync()
    [x] run_api_benchmarks(), run_contract_benchmarks(), run_semantic_benchmarks()


------ âœ… FASE 3 COMPLETA

[x] Modo determinÃ­stico
    [x] config.py - AgrobrConfig, set_mode(), get_config(), configure()
    [x] snapshots.py - SnapshotManifest, create_snapshot, load_from_snapshot
    [x] export.py - export_parquet, export_csv, export_json, verify_export
    [x] CLI: snapshot create/list/delete/use
    [x] Testes: 50 testes (config, snapshots, export)


------ âœ… FASE 4 COMPLETA

[x] Plugin system
    [x] plugins/__init__.py - Plugin, PluginMeta, register, get_plugin, list_plugins
    [x] SourcePlugin - fetch(), parse() para fontes de dados
    [x] ParserPlugin - can_parse(), parse(), priority para parsers
    [x] ExporterPlugin - export(), get_extension() para exportadores
    [x] ValidatorPlugin - validate() para validadores customizados
    [x] Testes: 10 testes (test_plugins.py)

[x] API stability decorators
    [x] stability.py - APIStatus, APIInfo, API registry
    [x] @stable(since="x.y.z") - marca API estÃ¡vel
    [x] @experimental(since="x.y.z") - marca API experimental (emite warning)
    [x] @deprecated(since, removed_in, replacement) - marca API deprecated
    [x] @internal - marca API interna (nÃ£o pÃºblica)
    [x] list_stable_apis(), list_experimental_apis(), list_deprecated_apis()
    [x] Testes: 14 testes (test_stability.py)

[x] SLA documentado
    [x] sla.py - Tier, FreshnessPolicy, LatencyTarget, AvailabilityTarget
    [x] SourceSLA - contrato de SLA por fonte
    [x] CEPEA_SLA - tier=CRITICAL, daily 18h, 99% uptime
    [x] CONAB_SLA - tier=STANDARD, monthly, 98% uptime
    [x] IBGE_SLA - tier=STANDARD, varies by pesquisa
    [x] NOTICIAS_AGRICOLAS_SLA - tier=BEST_EFFORT, 90% uptime
    [x] get_sla(), list_slas(), get_sla_summary()
    [x] Testes: 14 testes (test_sla.py)

[x] CertificaÃ§Ã£o de qualidade
    [x] quality.py - QualityLevel (GOLD/SILVER/BRONZE/UNCERTIFIED)
    [x] QualityCheck - check individual com status e detalhes
    [x] QualityCertificate - certificado completo com score e validade
    [x] certify(df) - executa checks (completeness, duplicates, schema, freshness, range)
    [x] quick_check(df) - retorna (level, score) rapidamente
    [x] Testes: 17 testes (test_quality.py)


================================================================================
                              FIM DO DOCUMENTO
================================================================================
